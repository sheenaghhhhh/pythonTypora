# 1 CS架构与BS架构

```python
# 【一】CS架构与BS架构
# CS架构和BS架构都是互联网中常见的网路模型

# 【二】CS架构
# 1.CS架构的定义
# C - Client - 客户端
# S - Server - 服务端

# CS - 客户端与服务端模型
# 安装的app 和 服务器 构成的架构

# 2.CS架构的优势
# a.应用服务器负载轻
# 某些数据处理的过程不会发生在服务端 - 减轻服务端的压力
# 打游戏 - 英雄/地图/活动 - 提前下载到本地
# 运行的时候 从本地中读取资源进行加载

# b.数据的存储功能划分明确
# 服务器只会存储用户的信息

# 3.CS架构的缺点
# 维护成本和开发成本很高
# 需要单独聘请一个 app 开发工程师
# 公司还要有运维


# 【三】BS架构
# 1.BS架构的定义
# B - Browser - 浏览器
# S - Server - 服务端

# BS - 浏览器与服务端模型
# 网页上的京东/淘宝

# 2.BS架构的优势
# a.维护和升级成本比较低
# 维护 - 只需要一个运维维护服务器即可
# 升级成本 - 只需要一个运维在程序需要升级的时候进行升级即可
# 王者升级 - 限制用户登录
# 在一个服务器上运行两个程序 - 端口不一致

# b.成本比较低 选择性更多
# 服务器其实就是一堆电脑硬件
# 选择不同的平台作为你的服务器硬件

# 3.BS架构的缺点
# 所有的服务数据全部在服务器上面
# 如果一旦数据量太大就会导致程序变卡
# 用户体验不好
```



# 2 网络编程基础

```python
# 【一】什么是网络编程
# 网络编程其实就是编程语言在计算机之间通信的一种方式
# 在前面的学习过程中我们都是在本地开发应用
# 数据交互只能发生在本地
# 为了解决不同设备之间进行数据交互的问题
# 网络编程中涉及到不同的技术和协议

# TCP/IP 协议: 传输控制协议/因特网协议 - 控制数据在网络中传输的协议 - 图片视频文字
# HTTP 协议: 超文本传输协议 - 以前在页面上只能展示文字 - 现在不仅有文字 还可以展示 图片视频等
# FTP 协议: 文件传输协议 - 以前传输数据 拿硬盘拷贝 - 现在用命令向服务器传输文件数据 也可以从服务器下载文件数据

# 总结: 基于互联网写代码就是网络编程

# 【二】学习网络编程的目的
# 主要是为了解决客户端和服务端之间数据传输的基本原理
# 通过学习网络编程我们后续可以自己开发基于客户端和服务端的响应模型

# 总结: 为了方便我们日后自己开发 CS 架构的模型

# 【三】网络编程的发展史
# 1.起源
# 计算机是美国发明的
# 计算机一开始是应用在 军方技术上
# 原来的计算机之间是不能进行数据传输的
# 为了解决不同计算机之间的数据传输问题 - 硬盘拷贝
# 硬盘拷贝的缺点: 速度慢 数据不安全
# 为了解决硬盘带来的缺点 - 开发出基于局域网的网线进行数据传输的技术
# 慢慢地发展过程中 军用技术 转为 民用技术

# 2.实际应用
# 随着计算机的普及和发展慢慢的网络编程技术应用到各种领域上面
# 比如我们现在看到的各种平台的前身就是上面的网络编程

# 【四】早期的通信发展史
# 1.早期通信介质 - 硬件设备
# 有自己的电脑
# 有了电脑以后装上软件就可以使用
# 只能自己玩 单机使用
# 彼此之间是相互独立的

# 2.早期通信介质 - 网线
# 如何和其他人一起
# 参考电话线的原理 出现了网线
# 只有大家相互连接的电脑才能进行数据交互

# 拨号电话拨号到指定的中转台 只有插入到对应的接口上才能进行通信
# 于是随着技术的发展出现了交换机
# 有一个公共的接口 有很多其他的分接口

# 3.早期的通信基础 - 互联网
# 虽然大家能一起玩但是 只能一个区域内的大家一起玩
# 于是出现了互联网
# 上海的要和北京的一起玩游戏 实现不了
# 因为网线介质的缺点很明显 只能一个区域内的人共享
# 大家将网线接入到一个大的介质中
# 某个不法分子想要接入到公共的互联网 - 有人可能会窃取数据 或者 有其他不同需求
# 为了统一不同设备之间数据交互的规范 出现了互联网协议
# 互联网协议的出现 统一了不同设备之间数据交互的规范 - internet协议

# 老电脑 - 需要点击桌面上的互联网 需要进行拨号

# 4.互联网协议 --- 互联网协议
# ● 那么连接两台计算机之间的 Internet 实际上就是
# ● 一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为“互联网协议”（Internet Protocol Suite)。
# ● 互联网协议的功能：
#   ○ 定义计算机如何接入 Internet，以及接入 Internet 的计算机通信的标准。
```



# 3 OSI七层协议

```python
# 【一】OSI七层协议
# 应用层：决定了向用户提供应用服务时通信的活动
# 表示层：数据格式化、数据加密
# 会话层：建立、管理、终止会话
# 传输层：定义传输数据的协议端口号，以及流控和差错校验
# 网络层：数据传输过程中的约束协议
# 数据链路层：网线 互联网介质
# 物理层：硬件设备的零件

# 【二】TCP/IP五层协议
# 应用层：所有的数据展示和建立管理会话
# 传输层：数据的传输
# 网络层：数据传输过程中的约束协议
# 数据链路层：网线 互联网介质
# 物理层：硬件设备的零件
```

![1036857-20200415215541847-564448301](assets/1036857-20200415215541847-564448301.gif)



# 4 TCP/IP五层协议

## 4.1 TCP/IP五层

- 物理层 - 底层硬件
- 数据链路层 - 数据帧封装
- 网络层
- 传输层
- 应用层

## 4.2 物理层

```python
# 构成：不同设备之间要进行组网 设备和设备之间连接网线
# 由来：计算机是基于电工作的 分高低电频 0 / 1
```

## 4.3 数据链路层

```python
# 构成：定义 0 / 1 数据如何在网线中传输
# 如果是一串没有规定的 01串码 没有意义 - 规范 约束 每一串 01 代码代表的含义
# 功能：定义电信号的组成方式

# 1.以太网协议
# 早期的时候每个公司都有自己的分组方式(局域网)
# 后来大家同一个局域网的分组方式标准 以太网协议(局域网数据交互的标准)
# ethernet 以太网协议
# 一组电信号就是一个数据包 - 帧
# 帧: 头head + 包data
# 头 head: 规范了发送者的源地址(6个字节) + 接受者的源地址(6个字节) + 传输的数据类型(6个字节)
# 包 data: 数据包的具体内容(最短 46 个字节, 最长 1500 个字节)

# 2.Mac地址
# head 头中包含 发送者的源地址(6个字节) + 接受者的源地址(6个字节)
# 发送者的源地址和接受者的源地址是什么东西
# ethernet(以太网协议)规定 每台接入局域网的设备必须具备网卡
# 网卡其实就是 发送者的源地址和接受者的源地址(Mac地址)
# Mac地址:每块网卡在被出厂的时候都会烧制上世界上唯一的一串Mac地址
# 长度为48位2进制(12位16进制表示) - 前6位 厂商编号 后6位 流水线号
# ether 00:16:3e:1a:83:a0

# 3.广播
# 有了 Mac地址 以后 两台主机连接上网线就可以进行沟通了
# 如果多台设备接入到同一个互联网中
# 局域网协议采用最原始的数据交互方式去找目标地址
# 在局域网内靠吼来找 一次性大喇叭喊出去 找 xxx
# 每一台设备检查自己的 Mac地址和目标地址是否一致 一致就接收 不一致就丢弃
```

## 4.4 网络层

```python
# 1.什么是互联网
# 互联网其实就是将全国的设备连接起来的介质

# 2.互联网建立的目的
# 为了大家不同设备之间进行数据交互

# 3.上网的本质
# 不同设备之间通过互联网传输数据

# 4.网络层的由来
# 前置条件:已经有了局域网的概念(ethernet + mac 地址 + 广播)
# 基于局域网交互的基础上又诞生出了大的局域网

# 5.网络层的功能
# 引入一套新的交互技术来实现 不同局域网之间进行数据交互
# 广播域 / 子网IP

# (1)IP协议
# 规定网络地址的协议就叫IP协议 现在广泛采用的是 Ipv4/Ipv6
# 规定网络地址由32位的2进制表示
# 范围 0.0.0.0 ~ 255.255.255.255

# 比如一个IP地址基本上都是由四段十进制数表示: 192.168.1.96

# (2)IP地址的组成部分
# 网络部分: 表示子网
# 主机部分: 表示主机

# 注意: 单纯的IP地址只是标识了Ip地址的种类
# 从网络部分或主机部分无法识别到一个IP所处的子网

# 比如 172.16.10.1 / 172.16.10.2
# 这两个IP地址的网络部分都是 172.16.10.0 但是不一定在同一个局域网下

# (3)子网掩码
# 子网掩码用来标识一个IP地址的网络部分和主机部分
# 在形式上等同于 IP地址, 也是一个32位二进制数字 网络部分用 1 表示 主机部分全是 0
# 比如 172.16.10.1 - 11111111.11111111.111111111.00000000
# 写成十进制表示: 255.255.255.0

# 知道子网掩码以后就可以判断两个ip地址是否处于同一个局域网下了

# (4)IP数据包
# 网络层规定 网络设备必须能够接收和发送IP数据包
# head(20 - 60个字节) + data(最高 65515字节)

# (5)arp协议
# 计算机底层基本靠吼
# 在所有上层的包到最后的时候都需要封装上一个以太头 再通过以太网发送
# 在计算发包的时候 获取到自己的源地址(Mac地址)很容易 如果想获取到对方的Mac地址 就得通过arp解包

# arp协议就是通过广播的发送数据包获取目标Mac地址的功能
```

## 4.5 传输层

```python
# 1.由来
# 网络层的IP帮助我们能够区分互联网中的不同设备 - Mac地址区分不同设备
# 一台设备上面可能会运行很多应用程序 qq / vx ...
# 虽然能够找到目标的设备 - 但如何区分我是给qq还是vx发送了信息呢?
# 于是就诞生了传输层技术 - 端口
# 让不同的设备启动在不同的端口上
# 1314: alist页面
# 80: 访问到nginx页面
# 8008: qq
# 8009: vx
# 从另一台设备 上的vx 向 当前设备的vx发送信息
# 192.168.1.252:8009 -> 192.168.1.96:8009

# 2.功能
# 建立不同设备之间端口到端口的通信
# 端口范围 0 - 65535
# 0 - 1023 系统占用的端口

# 3.TCP协议和UDP协议
# 3.1 TCP协议
# 可靠传输协议(流式协议)
# 传输数据的过程就像流水一样可以不间断地传输数据,理论上数据可以无限大,但还是有一定限制

# TCP三次握手: 发生在建立连接阶段
# TCP四次挥手: 发生在断开连接阶段

# 3.2 UDP协议
# 不可靠传输协议(报式协议)
# 传输数据的过程就像报文一样 数据包之间没有关联 独立传输
# 传输数据的过程就像快递一样快递员把快递送到你的手上快递和快递之间没有任何关联
```

## 4.6 应用层

```python
# 1.由来
# 用户使用的都是应用程序,应用程序是建立在操作系统至上的

# 2.功能
# 规定应用程序之间传输数据的格式
# TCP协议可以为各种各样的程序传递数据 但是具体的数据加密过程是由当前程序决定的

# JS逆向: 发生在网页上
# APP逆向: 主要发生在app内部
```

# 5 SOCKET

```python
# 不同设备之间的程序数据交互的唯一标识是端口Port
# 两个程序之间进行交互的前提是有一个唯一的表示来表示当前的程序
# 自己的设备上还会有不同的应用程序如何表示自己设备上的不同应用程序 PID

# 端口号(Port): 用来区分不同设备之间的程序
# 进程号(Pid): 用来区分同一台设备之间不同的应用程序

# TCP协议中已经知道 IP + PORT 用来表示唯一主机的唯一进程了
# 但是如果是本机中的不同程序之间交互 借助 SOCKET

# Socket 是一个抽象层,它是一组接口
# 存在于 应用层和传输层之间
```

![202312012044734](assets/202312012044734.png)



# 6 三次握手和四次挥手

```python
# 三次握手和四次挥手发生在TCP协议的传输过程中

# 【一】三次握手
# 发生在TCP建立连接的过程中

# 第一次握手: 由客户端发起(携带SYN=1, seq=x), 发送给服务端
# SYN:当前是客户端发起的链接 seq:代表当前是哪个客户端发起的链接
# 第二次握手: 由服务端发起(携带SYN=1, ACK=1, seq=y, ack=x+1), 发送给客户端
# ACK:确认收到客户端的链接请求 seq:代表当前是哪个服务端发起的链接
# 当前服务端已经收到了连接请求并同意当前的链接请求
# 第三次握手: 由客户端发起(携带ACK=1, seq=x+1, ack=y+1), 发送给服务端
# 服务端同意建立连接


# 【二】四次挥手
# 发生在TCP断开连接的过程中

# 第一次挥手：由客户端发起(携带FIN=1, seq=u) ，发送给服务端
# 第二次挥手：由服务端发起(携带ACK=1, seq=v, ack=u+1) ，发送给客户端 --- 我可能还有数据没有传输完成不允许断开
# 第三次挥手：由服务端发起(携带FIN=1, seq=w, ack=u+1) ，发送给客户端 --- 数据传输完成了 允许断开连接
# 第四次挥手：由客户端发起(携带ACK=1, seq=u+1, ack=w+1) ，发送给服务端
```



TASK：

1. 完成今日代码和笔记整理(3:00前)
2. 上传到Github和云盘上(3:30前)
3. 回家后对今日学习内容进行复习 自己再去学习三次握手部分(8:00后)
4. 剩余时间先写选课项目(5:30前)